<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Multiplayer Game</title>
  <style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }

    body { 
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #ffd700 0%, #ffed4e 50%, #9b59b6 100%);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
    }

    h1 { 
        color: white;
        text-align: center;
        margin: 20px 0;
        font-size: 2.5em;
        text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.3);
    }

    .game-container {
        background: white;
        padding: 20px;
        border-radius: 20px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    }

    canvas { 
        background: linear-gradient(135deg, #fff9e6 0%, #f5f0ff 100%);
        display: block;
        border: 4px solid #9b59b6;
        border-radius: 10px;
        box-shadow: inset 0 0 20px rgba(155, 89, 182, 0.1);
    }

    .controls {
        text-align: center;
        margin-top: 15px;
        color: #333;
        font-size: 0.95em;
        background: #fff9e6;
        padding: 10px;
        border-radius: 10px;
        border: 2px solid #ffd700;
    }

    .controls strong {
        color: #9b59b6;
    }
  </style>
</head>
<body>
    <h1>ðŸŽ® COM440 Multi-User Game ðŸŽ®</h1>
    <div class="game-container">
        <canvas id="game" width="800" height="600"></canvas>
        <div class="controls">
            <strong>Controls:</strong> Use <strong>W A S D</strong> to move | Click to jump
        </div>
    </div>

  <script src="/socket.io/socket.io.js"></script>
<script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const msg = sessionStorage.getItem('mySessionName') || '_';
    const socket = io({
        auth: { token: msg }
    });

    let playerId = null;
    const players = {};
    
    // NEW: Velocity system
    const keys = { w: false, a: false, s: false, d: false };
    const velocity = { x: 0, y: 0 };
    const ACCELERATION = 0.5;
    const MAX_SPEED = 8;
    const FRICTION = 0.85;

    socket.on('init', ({ id, players: allPlayers }) => {
        playerId = id;
        Object.assign(players, allPlayers);
    });

    socket.on('join', (player) => {
    players[player.id] = player;
    if (players[player.id].alive === undefined) {
        players[player.id].alive = true;  // Ensure alive is set
    }
});

    socket.on('move', ({ id, x, y }) => {
        if (players[id]) {
            players[id].x = x;
            players[id].y = y;
        }
    });

    socket.on('update', ({ players: allPlayers }) => {
    for (const id in allPlayers) {
        if (!players[id]) {
            players[id] = {};  // Initialize if doesn't exist
        }
        players[id].x = allPlayers[id].x;
        players[id].y = allPlayers[id].y;
        players[id].health = allPlayers[id].health;
        players[id].color = allPlayers[id].color;
        players[id].alive = allPlayers[id].alive !== undefined ? allPlayers[id].alive : true;  // Default to true
    }
});
      
    socket.on('leave', (id) => {
        delete players[id];
    });

    // NEW: Track key presses
    document.addEventListener('keydown', (e) => {
        if (e.key === 'w') keys.w = true;
        if (e.key === 'a') keys.a = true;
        if (e.key === 's') keys.s = true;
        if (e.key === 'd') keys.d = true;
    });

    document.addEventListener('keyup', (e) => {
        if (e.key === 'w') keys.w = false;
        if (e.key === 'a') keys.a = false;
        if (e.key === 's') keys.s = false;
        if (e.key === 'd') keys.d = false;
    });

    // REMOVED: canvas click event (no more jump)

    function updateMovement() {
    const me = players[playerId];
    if (!me || !me.alive) return;

    // Apply acceleration based on keys held
    if (keys.w) velocity.y -= ACCELERATION;
    if (keys.s) velocity.y += ACCELERATION;
    if (keys.a) velocity.x -= ACCELERATION;
    if (keys.d) velocity.x += ACCELERATION;

    // Apply friction
    velocity.x *= FRICTION;
    velocity.y *= FRICTION;

    // Limit to max speed
    const speed = Math.sqrt(velocity.x ** 2 + velocity.y ** 2);
    if (speed > MAX_SPEED) {
        velocity.x = (velocity.x / speed) * MAX_SPEED;
        velocity.y = (velocity.y / speed) * MAX_SPEED;
    }

    // Update position
    const oldX = me.x;
    const oldY = me.y;
    me.x += velocity.x;
    me.y += velocity.y;

    // Check if hit edge BEFORE clamping
    const hitEdge = (me.x <= 20 || me.x >= canvas.width - 20 || 
                     me.y <= 20 || me.y >= canvas.height - 20);
    
    if (hitEdge) {
        // Notify server of edge collision
        socket.emit('hitEdge');
    }

    // NOW clamp to bounds
    me.x = Math.max(20, Math.min(canvas.width - 20, me.x));
    me.y = Math.max(20, Math.min(canvas.height - 20, me.y));

    // Send position to server
    socket.emit('move', { x: me.x, y: me.y });
}

    // Call movement update every frame
    setInterval(updateMovement, 1000 / 60); // 60 FPS
      
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        for (const id in players) {
            const p = players[id];
            const isMe = (id === playerId);

            if (p.alive) {
                // Draw living player (same as before)
                const gradient = ctx.createRadialGradient(p.x, p.y, 5, p.x, p.y, 20);
                gradient.addColorStop(0, p.color);
                gradient.addColorStop(1, adjustColor(p.color, -30));
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 20, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = isMe ? '#ffd700' : '#9b59b6';
                ctx.lineWidth = isMe ? 4 : 2;
                ctx.stroke();
            } else {
                // NEW: Draw dead player as X
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                
                // Draw X
                ctx.beginPath();
                ctx.moveTo(p.x - 15, p.y - 15);
                ctx.lineTo(p.x + 15, p.y + 15);
                ctx.moveTo(p.x + 15, p.y - 15);
                ctx.lineTo(p.x - 15, p.y + 15);
                ctx.stroke();
            }

            // Draw player name
            ctx.font = "bold 14px 'Segoe UI'";
            ctx.textAlign = "center";
            const nameText = p.name + (p.alive ? '' : ' (DEAD)');
            const textWidth = ctx.measureText(nameText).width;
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fillRect(p.x - textWidth/2 - 5, p.y - 45, textWidth + 10, 20);
            ctx.strokeStyle = p.alive ? '#9b59b6' : '#ff0000';
            ctx.lineWidth = 2;
            ctx.strokeRect(p.x - textWidth/2 - 5, p.y - 45, textWidth + 10, 20);
            
            ctx.fillStyle = p.alive ? '#9b59b6' : '#ff0000';
            ctx.fillText(nameText, p.x, p.y - 32);

            // Draw health bar (only if alive)
            if (p.alive) {
                const barWidth = 60;
                const barHeight = 8;
                const barX = p.x - barWidth/2;
                const barY = p.y + 30;
                
                ctx.fillStyle = '#e0e0e0';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                
                ctx.strokeStyle = '#9b59b6';
                ctx.lineWidth = 2;
                ctx.strokeRect(barX, barY, barWidth, barHeight);
                
                const healthPercent = p.health / 100;
                const healthWidth = barWidth * healthPercent;
                
                const healthGradient = ctx.createLinearGradient(barX, barY, barX + barWidth, barY);
                if (healthPercent > 0.5) {
                    healthGradient.addColorStop(0, '#ffd700');
                    healthGradient.addColorStop(1, '#ffed4e');
                } else if (healthPercent > 0.25) {
                    healthGradient.addColorStop(0, '#ffed4e');
                    healthGradient.addColorStop(1, '#ff9900');
                } else {
                    healthGradient.addColorStop(0, '#ff6600');
                    healthGradient.addColorStop(1, '#ff0000');
                }
                
                ctx.fillStyle = healthGradient;
                ctx.fillRect(barX, barY, healthWidth, barHeight);
                
                ctx.font = "bold 11px 'Segoe UI'";
                ctx.fillStyle = '#333';
                ctx.textAlign = "center";
                ctx.fillText(Math.round(p.health) + '%', p.x, barY + barHeight + 12);
            }
        }
        
        requestAnimationFrame(draw);
    }

    function adjustColor(color, amount) {
        const num = parseInt(color.replace("#",""), 16);
        const r = Math.max(0, Math.min(255, (num >> 16) + amount));
        const g = Math.max(0, Math.min(255, ((num >> 8) & 0x00FF) + amount));
        const b = Math.max(0, Math.min(255, (num & 0x0000FF) + amount));
        return "#" + ((r << 16) | (g << 8) | b).toString(16).padStart(6, '0');
    }

    draw();
</script>