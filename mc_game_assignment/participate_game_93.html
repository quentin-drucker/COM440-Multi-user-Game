<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Multiplayer Game</title>
  <style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }

    body { 
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #ffd700 0%, #ffed4e 50%, #9b59b6 100%);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
    }

    h1 { 
        color: white;
        text-align: center;
        margin: 20px 0;
        font-size: 2.5em;
        text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.3);
    }

    .game-container {
        background: white;
        padding: 20px;
        border-radius: 20px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    }

    canvas { 
        background: linear-gradient(135deg, #fff9e6 0%, #f5f0ff 100%);
        display: block;
        border: 4px solid #9b59b6;
        border-radius: 10px;
        box-shadow: inset 0 0 20px rgba(155, 89, 182, 0.1);
    }

    .controls {
        text-align: center;
        margin-top: 15px;
        color: #333;
        font-size: 0.95em;
        background: #fff9e6;
        padding: 10px;
        border-radius: 10px;
        border: 2px solid #ffd700;
    }

    .controls strong {
        color: #9b59b6;
    }
  </style>
</head>
<body>
    <h1>ðŸŽ® COM440 Multi-User Game ðŸŽ®</h1>
    <div class="game-container">
        <canvas id="game" width="800" height="600"></canvas>
        <div class="controls">
            <strong>Goal:</strong> Try to knock everyone out!
        </div>
        <div class="controls">
            <strong>Controls:</strong> Press your <strong>W A S D</strong> keys to move your player.
        </div>
    </div>

  <script src="/socket.io/socket.io.js"></script>
<script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const msg = sessionStorage.getItem('mySessionName') || '_';
    const socket = io({
        auth: { token: msg }
    });

    let playerId = null;
    const players = {};
    
    // NEW: Velocity system
    const keys = { w: false, a: false, s: false, d: false };
    const velocity = { x: 0, y: 0 };
    const ACCELERATION = 0.5;
    const MAX_SPEED = 12;
    const BOUNCE_SPEED = MAX_SPEED * 2;  // [NEW]: strong 'push' away from wall (for player on contact with wall)
    const FRICTION = 0.85;
    // Sumo tuning
    const PLAYER_RADIUS = 20;     // matches the circle radius used in draw()
    const ARENA_MARGIN = 20;      // same margin used in hitEdge checks
    const BUMP_POWER = 40;          // how hard you shove others
    const BUMP_COOLDOWN_MS = 150;   // min time between bumps on same target
    const lastBumpTime = {};        // targetId -> last bump timestamp

    let endMessage = null;        // set when round ends
    let roundStarted = false;     // becomes true once >= 2 players are alive at once




    socket.on('init', ({ id, players: allPlayers }) => {
        playerId = id;
        Object.assign(players, allPlayers);
    });

    socket.on('join', (player) => {
    players[player.id] = player;
    if (players[player.id].alive === undefined) {
        players[player.id].alive = true;  // Ensure alive is set
    }
});

    socket.on('move', ({ id, x, y }) => {
        if (players[id]) {
            players[id].x = x;
            players[id].y = y;
        }
    });

    socket.on('update', ({ players: allPlayers }) => {
    // for (const id in allPlayers) {
    //     if (!players[id]) {
    //         players[id] = {};  // Initialize if doesn't exist
    //     }
    //     players[id].x = allPlayers[id].x;
    //     players[id].y = allPlayers[id].y;
    //     players[id].health = allPlayers[id].health;
    //     players[id].color = allPlayers[id].color;
    //     players[id].alive = allPlayers[id].alive !== undefined ? allPlayers[id].alive : true;  // Default to true
    // }
    for (const id in allPlayers) {
        players[id] = { ...allPlayers[id] };
    }

    // Remove any players that no longer exist on server
    for (const id in players) {
        if (!allPlayers[id]) {
            delete players[id];
        }
    }
});
      
    socket.on('leave', (id) => {
        delete players[id];
    });

    // NEW: Track key presses
    document.addEventListener('keydown', (e) => {
        if (e.key === 'w') keys.w = true;
        if (e.key === 'a') keys.a = true;
        if (e.key === 's') keys.s = true;
        if (e.key === 'd') keys.d = true;
    });

    document.addEventListener('keyup', (e) => {
        if (e.key === 'w') keys.w = false;
        if (e.key === 'a') keys.a = false;
        if (e.key === 's') keys.s = false;
        if (e.key === 'd') keys.d = false;
    });

    // REMOVED: canvas click event (no more jump)


    // [NEW] helper function -- Push other players away when we collide (and recoil a bit ourselves)
    function resolvePlayerCollisions(me) {
        const minDist = PLAYER_RADIUS * 2;

        for (const id in players) {
            if (id === playerId) continue;
            const other = players[id];
            if (!other || !other.alive) continue;

            // Vector from me â†’ other
            const dx = other.x - me.x;
            const dy = other.y - me.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist > 0 && dist < minDist) {
                const now = Date.now();
                if (lastBumpTime[id] && now - lastBumpTime[id] < BUMP_COOLDOWN_MS) {
                    // Recently bumped this same player; skip to avoid spam
                    continue;
                }
                lastBumpTime[id] = now;

                const overlap = minDist - dist;
                const nx = dx / dist;   // unit vector from me to other
                const ny = dy / dist;

                // Slightly separate myself so we don't visually overlap
                me.x -= nx * overlap * 0.5;
                me.y -= ny * overlap * 0.5;

                // Recoil me a bit in opposite direction
                velocity.x -= nx * BUMP_POWER * 0.3;
                velocity.y -= ny * BUMP_POWER * 0.3;

                // Tell the server to shove the OTHER player away from me
                socket.emit('bump', {
                    targetId: id,
                    impulseX: nx * BUMP_POWER,
                    impulseY: ny * BUMP_POWER
                });
            }
        }
    }

    // [NEW] helper function
    function handleWallBounce(me) {
        let bounced = false;

        // Check each side individually to flip correct velocity component
        if (me.x <= ARENA_MARGIN) {
            me.x = ARENA_MARGIN;
            velocity.x = BOUNCE_SPEED;     // push to the right
            bounced = true;
        } else if (me.x >= canvas.width - ARENA_MARGIN) {
            me.x = canvas.width - ARENA_MARGIN;
            velocity.x = -BOUNCE_SPEED;    // push to the left
            bounced = true;
        }

        if (me.y <= ARENA_MARGIN) {
            me.y = ARENA_MARGIN;
            velocity.y = BOUNCE_SPEED;     // push down
            bounced = true;
        } else if (me.y >= canvas.height - ARENA_MARGIN) {
            me.y = canvas.height - ARENA_MARGIN;
            velocity.y = -BOUNCE_SPEED;    // push up
            bounced = true;
        }

        if (bounced) {
            // Tell server so it can reduce health
            socket.emit('hitEdge');
        }
    }


    function updateMovement() {
    const me = players[playerId];
    if (!me) return;

    // [NEW] If dead, stop velocity + don't move
    if (!me.alive) {
        velocity.x = 0;
        velocity.y = 0;
        return;
    }

    // Apply acceleration based on keys held
    if (keys.w) velocity.y -= ACCELERATION;
    if (keys.s) velocity.y += ACCELERATION;
    if (keys.a) velocity.x -= ACCELERATION;
    if (keys.d) velocity.x += ACCELERATION;

    // Apply friction
    velocity.x *= FRICTION;
    velocity.y *= FRICTION;

    // Limit to max speed
    const speed = Math.sqrt(velocity.x ** 2 + velocity.y ** 2);
    if (speed > MAX_SPEED) {
        velocity.x = (velocity.x / speed) * MAX_SPEED;
        velocity.y = (velocity.y / speed) * MAX_SPEED;
    }

    // Update position
    const oldX = me.x;
    const oldY = me.y;
    me.x += velocity.x;
    me.y += velocity.y;

    // Check if hit edge BEFORE clamping
    const hitEdge = (me.x <= 20 || me.x >= canvas.width - 20 || 
                     me.y <= 20 || me.y >= canvas.height - 20);
    
    if (hitEdge) {
        // // Notify server of edge collision
        // socket.emit('hitEdge');
        handleWallBounce(me); // [NEW] -- calls above helper function
    }

    // NOW clamp to bounds
    me.x = Math.max(20, Math.min(canvas.width - 20, me.x));
    me.y = Math.max(20, Math.min(canvas.height - 20, me.y));

    resolvePlayerCollisions(me); // [NEW] -- calls above helper function

    // Send position to server
    socket.emit('move', { x: me.x, y: me.y });
}

    // Call movement update every frame
    setInterval(updateMovement, 1000 / 60); // 60 FPS
    

    // [NEW] -- helper function (Triggers the 'Everyone was eliminated!' text when only 1 player remains)
    function updateEndState() {
        const alivePlayers = [];
        for (const id in players) {
            const p = players[id];
            if (p && p.alive) alivePlayers.push(p);
        }

        // If we haven't officially "started" the round yet, see if we now have >= 2 players
        if (!roundStarted && alivePlayers.length >= 2) {
            roundStarted = true;
        }

        // If game already ended or round hasn't really started, don't show any message
        if (endMessage || !roundStarted) return;

        // Only once a round has started do we look for a winner
        if (alivePlayers.length <= 1) {
            if (alivePlayers.length === 0) {
                endMessage = "Everyone was eliminated!";
            } else if (alivePlayers[0].id === playerId) {
                endMessage = "You win!";
            } else {
                endMessage = `${alivePlayers[0].name} wins`;
            }
        }
    }




    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        for (const id in players) {
            const p = players[id];
            const isMe = (id === playerId);

            if (p.alive) {
                // Draw living player (same as before)
                const gradient = ctx.createRadialGradient(p.x, p.y, 5, p.x, p.y, 20);
                gradient.addColorStop(0, p.color);
                gradient.addColorStop(1, adjustColor(p.color, -30));
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 20, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = isMe ? '#ffd700' : '#9b59b6';
                ctx.lineWidth = isMe ? 4 : 2;
                ctx.stroke();
            } else {
                // NEW: Draw dead player as X
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                
                // Draw X
                ctx.beginPath();
                ctx.moveTo(p.x - 15, p.y - 15);
                ctx.lineTo(p.x + 15, p.y + 15);
                ctx.moveTo(p.x + 15, p.y - 15);
                ctx.lineTo(p.x - 15, p.y + 15);
                ctx.stroke();
            }

            // Draw player name
            ctx.font = "bold 14px 'Segoe UI'";
            ctx.textAlign = "center";
            const nameText = p.name + (p.alive ? '' : ' (DEAD)');
            const textWidth = ctx.measureText(nameText).width;
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fillRect(p.x - textWidth/2 - 5, p.y - 45, textWidth + 10, 20);
            ctx.strokeStyle = p.alive ? '#9b59b6' : '#ff0000';
            ctx.lineWidth = 2;
            ctx.strokeRect(p.x - textWidth/2 - 5, p.y - 45, textWidth + 10, 20);
            
            ctx.fillStyle = p.alive ? '#9b59b6' : '#ff0000';
            ctx.fillText(nameText, p.x, p.y - 32);

            // Draw health bar (only if alive)
            if (p.alive) {
                const barWidth = 60;
                const barHeight = 8;
                const barX = p.x - barWidth/2;
                const barY = p.y + 30;
                
                ctx.fillStyle = '#e0e0e0';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                
                ctx.strokeStyle = '#9b59b6';
                ctx.lineWidth = 2;
                ctx.strokeRect(barX, barY, barWidth, barHeight);
                
                const healthPercent = p.health / 100;
                const healthWidth = barWidth * healthPercent;
                
                const healthGradient = ctx.createLinearGradient(barX, barY, barX + barWidth, barY);
                if (healthPercent > 0.5) {
                    healthGradient.addColorStop(0, '#ffd700');
                    healthGradient.addColorStop(1, '#ffed4e');
                } else if (healthPercent > 0.25) {
                    healthGradient.addColorStop(0, '#ffed4e');
                    healthGradient.addColorStop(1, '#ff9900');
                } else {
                    healthGradient.addColorStop(0, '#ff6600');
                    healthGradient.addColorStop(1, '#ff0000');
                }
                
                ctx.fillStyle = healthGradient;
                ctx.fillRect(barX, barY, healthWidth, barHeight);
                
                ctx.font = "bold 11px 'Segoe UI'";
                ctx.fillStyle = '#333';
                ctx.textAlign = "center";
                ctx.fillText(Math.round(p.health) + '%', p.x, barY + barHeight + 12);
            }
        }
        
        // [NEW] After drawing everyone, check if the round is over
        updateEndState();

        if (endMessage) {
            // Dark overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Centered message
            ctx.font = "bold 48px 'Segoe UI'";
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.fillText(endMessage, canvas.width / 2, canvas.height / 2);

            // Stop animating positions after the round ends
            return;
        }
        

        requestAnimationFrame(draw);
    }


    function adjustColor(color, amount) {
        const num = parseInt(color.replace("#",""), 16);
        const r = Math.max(0, Math.min(255, (num >> 16) + amount));
        const g = Math.max(0, Math.min(255, ((num >> 8) & 0x00FF) + amount));
        const b = Math.max(0, Math.min(255, (num & 0x0000FF) + amount));
        return "#" + ((r << 16) | (g << 8) | b).toString(16).padStart(6, '0');
    }

    draw();
</script>